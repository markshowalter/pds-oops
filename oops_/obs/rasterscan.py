################################################################################
# oops_/obs/rasterscan.py: Subclass RasterScan of class Observation
#
# 4/3/12 BSW & MRS
################################################################################

import numpy as np

from oops_.obs.observation_ import Observation
from oops_.array.all import *
import oops_.frame.all as frame_
import oops_.path.all as path_

class RasterScan(Observation):
    """A RasterScan is subclass of Observation consisting of a 2-D image
    generated by sweeping a strip of sensors across a field of view in one
    direction and then the other.

    The FOV object is assumed to define the entire field of view, even if the
    reality is that a the image is composed of a single sensor sweeping out the
    FOV.
    """

    def __init__(self, tstride, texp,
                 target, time, fov, path_id, frame_id, **subfields):
        """Constructor for a RasterScan observation.

        Input:
            tstride     a tuple containing the time increment from one pixel
                        step to the next along the (u,v) axes.
            texp        the exposure time in seconds for one pixel. This will be
                        shorter than either tstride due to readout times, mirror
                        positioning delays, etc.

            target      the registered name of the target body.
            time        a tuple or Pair defining the start time and end time of
                        the observation overall, in seconds TDB.
            fov         a FOV (field-of-view) object, which describes the field
                        of view including any spatial distortion. It maps
                        between spatial coordinates (u,v) and instrument
                        coordinates (x,y).
            path_id     the registered ID of a path co-located with the
                        instrument.
            frame_id    the registered ID of a coordinate frame fixed to the
                        optics of the instrument. This frame should have its
                        Z-axis pointing outward near the center of the line of
                        sight, with the X-axis pointing rightward and the y-axis
                        pointing downward.
            subfields   a dictionary containing all of the optional attributes.
                        Additional subfields may be included as needed.
        """

        self.tstride = tstride
        self.texp = texp

        self.target = target
        self.time = time
        self.fov = fov
        self.path_id = path_id
        self.frame_id = frame_id

        self.subfields = {}
        for key in subfields.keys():
            self.insert_subfield(key, subfields[key])

        self.duv_dt = Pair(1./self.tstride[0], 1./self.tstride[1])

        return

    def times_at_uv(self, uv_pair, extras=()):
        """Returns the start and stop times of the specified spatial pixel
        (u,v).

        Input:
            uv_pair     a Pair of spatial (u,v) coordinates in and observation's
                        field of view. The coordinates need not be integers, but
                        any fractional part is truncated.
            extras      a tuple of Scalar index values defining any extra index
                        values relevant to the conversion from (u,v) to time.
        Return:         a tuple containing Scalars of the start time and stop
                        time of each (u,v) pair, as seconds TDB.

                        If derivs is True, then each time has a subfield "d_duv"
                        defining the change in time associated with a 1-pixel
                        step along the u and v axes. This is represented by a
                        MatrixN with item shape [1,2].

        For (x,y) pairs that fall outside the field of view, the returne values
        time and index are masked.
        """

        uv_pair = Pair.as_pair(uv_pair)
        mask = uv_pair.mask | ~self.fov.is_inside(uv_pair)

        time0 = Scalar(self.time[0] + uv_pair.vals[0] * self.tstride[0] +
                                      uv_pair.vals[1] * self.tstride[1], mask)
        time1 = time0 + self.texp

        return (time0, time1)

    def sweep_duv_dt(self, uv_pair, extras=()):
        """Returns the mean local sweep speed of the instrument in the (u,v)
        directions.

        Input:
            uv_pair     a Pair of spatial indices (u,v).
            extras      Scalars of any extra index values needed to define the
                        timing of array elements.

        Return:         a Pair containing the local sweep speed in units of
                        pixels per second in the (u,v) directions.
        """

        return self.duv_dt

################################################################################
# UNIT TESTS
################################################################################

import unittest

class Test_RasterScan(unittest.TestCase):

    def runTest(self):

        pass

########################################
if __name__ == '__main__':
    unittest.main(verbosity=2)
################################################################################
