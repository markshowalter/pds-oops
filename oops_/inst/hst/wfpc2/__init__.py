################################################################################
# oops/instrument/hst/wfpc2/__init__.py
################################################################################

import pyfits
import oops

################################################################################
# Standard class methods
################################################################################

def from_file(filespec, parameters={}):
    """A general, static method to return an Observation object based on a given
    data file generated by HST/WFPC2."""

    # Open the file
    hst_file = pyfits.open(filespec)

    # Make an instance of the NICMOS class
    this = WFPC2()

    # Confirm that the telescope is HST
    if this.telescope_name(hst_file) != "HST":
        raise IOError("not an HST file: " + this.filespec(hst_file))

    # Confirm that the instrument is WFPC2
    if this.instrument_name(hst_file) != "NICMOS":
        raise IOError("not an HST/WFPC2 file: " + this.filespec(hst_file))

    return from_opened_fitsfile(hst_file, parameters)

def from_opened_fitsfile(hst_file, parameters={}):
    """A general, static method to return an Observation object based on an HST
    data file generated by HST/WFPC2."""

    # Make an instance of the WFPC2 class
    this = WFPC2()

    # Figure out the layer; otherwise use PC1
    try:
        layer = parameters["layer"]
    except KeyError:
        layer = 1

################################################################################
# Class WFPC2
################################################################################

IDC_DICT = {}

GENERAL_SYN_FILES = ["OTA/hst_ota_???_syn.fits",
                     "WFPC2/wfpc2_optics_???_syn.fits"]

FILTER_SYN_FILE_PARTS = ["WFPC2/wfpc2_", "_???_syn.fits"]

class WFPC2(oops.instrument.hst.HST):
    """This class defines functions and properties unique to the WFPC2
    instrument. Everything else is inherited from higher levels in the class
    hierarchy.

    Objects of this class are empty; they only exist to support inheritance.
    """

    # WFPC2 is treated as a single detector
    def detector_name(self, hst_file):
        """Returns the name of the detector on the HST instrument that was used
        to obtain this file."""

        return ""

    # WFPC2 has two filter wheels. Names are identified by FITS parameters
    # FILTNAM1 and FILTNAM2 in the first header.
    def filter_name(self, hst_file):
        """Returns the name of the filter for this particular ACS detector.
        Overlapped filters are separated by a plus sign."""

        name1 = hst_file[0].header["FILTNAM1"].strip()
        name2 = hst_file[0].header["FILTNAM2"].strip()

        if name1 == "":
            if name2[0:5] == "":
                return "CLEAR"
            else:
                return name2
        else:
            if name2 == "":
                return name1
            else:
                return name1 + "+" + name2

    def data_from_file(self, hst_file, parameters={}):
        """Returns an array containing the data. Use layer=1-4 for PC1, WF2,
        WF3 and WF4."""

        # Determine the layer of the FITS file to read
        try:
            layer = parameters["layer"]
        except KeyError:
            layer = 1

        return hst_file[layer].data

    MASK_TAG_DICT = {"d0":"q0", "D0":"Q0", "c0":"c1", "C0":"C1"}

    def mask_array(self, hst_file, parameters={}):
        """Returns an array containing the data. Use layer=1-4 for PC1, WF2,
        WF3 and WF4."""

        # Unlike the other HST instruments, WFPC2 masks are saved in a separate
        # file. We attempt to open the mask file under the assumption that it is
        # in the same directory as the data file.

        # Quality masks for raw files ("*d0m.fits") end in "q0m.fits".
        # Quality masks for calibrated files ("*c0m.fits") end in "c1m.fits".

        # Get the full path to the image file
        data_filespec = self.filespec()

        # Extract the extension
        (head,tail) = os.path.splitext(data_filespec)

        # Attempt to define the mask filespec
        data_tag = head[-3:-1]
        try:
            mask_tag = MASK_TAG_DICT[data_tag]
        except:
            raise IOError("Unable to identify mask file for " + data_filespec)

        # Attempt to load the mask. Throws an IOError on failure
        mask_filespec = os.path.join(head[:-3] + mask_tag + head[-1], tail)

        f = pyfits.open(mask_filespec)
        mask_array = f[layer].data
        f.close()

        return mask_array

    FRAME_SUFFIX_LIST = ["", "_PC1", "_WF2", "_WF3", "_WF4"]

    def define_frame(self, hst_file, parameters={}):
        """Returns the Cmatrix Frame that rotates from J2000 coordinates into
        the frame of the HST observation.
        """

        # Determine the layer of the FITS file
        try:
            layer = parameters["layer"]
        except KeyError:
            layer = 1

        header1 = hst_file[layer].header
        ra    = header1["CRVAL1"]
        dec   = header1["CRVAL2"]
        clock = header1["ORIENTAT"]
        frame_id = hst_file[0].header["FILENAME"] + FRAME_SUFFIX_LIST[layer]

        return oops.Cmatrix(ra, dec, clock, frame_id)

    # The IDC dictionaries for WFPC2 are keyed by (FILTNAM1, FILTNAM2, DETCHIP)
    def define_fov(self, hst_file, parameters={}):
        """Returns an FOV object defining the field of view of the given image
        file and layer, where layers 1-4 refer to PC1, WF2, WF3 and WF4.
        """

        global IDC_DICT

        # Load the dictionary of IDC parameters if necessary
        if IDC_DICT is None:
            IDC_DICT = self.load_idc_dict(hst_file, ("FILTNAM1",
                                                     "FILTNAM2", "DETCHIP"))

        # Determine the layer of the FITS file
        try:
            layer = parameters["layer"]
        except KeyError:
            layer = 1

        # Define the key into the dictionary
        idc_key = (hst_file[0].header["FILTNAM1"].strip(),
                   hst_file[0].header["FILTNAM2"].strip(), layer)

        return self.construct_fov(IDC_DICT[idc_key], hst_file)

    def select_syn_files(self, hst_file, parameters={}):
        """Returns the list of SYN files containing profiles that are to be
        multiplied together to obtain the throughput of the given instrument,
        detector and filter combination."""

        # Copy all the standard file names
        syn_filenames = []
        for filename in GENERAL_SYN_FILES:
            syn_filenames.append(filename)

        # Add the filter file names
        for filter_name in (hst_file[0].header["FILTNAM1"],
                            hst_file[0].header["FILTNAM2"]):
            filter_name = filter_name.strip()
            if filter_name != "":
                syn_filenames.append(FILTER_SYN_FILE[0] +
                                     filter_name.lower() +
                                     FILTER_SYN_FILE[1])

        return syn_filenames

################################################################################
